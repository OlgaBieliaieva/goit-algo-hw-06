# Порівняння алгоритмів DFS та BFS для пошуку шляхів у графі

## Опис завдання
Метою цього завдання було реалізувати два алгоритми пошуку шляхів у графі: **DFS** та **BFS**. Граф представляє соціальну мережу, створену у завданні 1, зберігається у форматі `adjlist`. Після реалізації алгоритмів здійснено порівняння шляхів, знайдених обома методами.

## Результати
Для заданого графа:

- **Початкова вершина**: `Alice`
- **Цільова вершина**: `David`

Результати виконання алгоритмів:

- **DFS шлях**: `['Alice', 'Eve', 'Frank', 'Grace', 'Helen', 'David']`
- **BFS шлях**: `['Alice', 'Bob', 'Charlie', 'David']`

## Пояснення різниці в шляхах
- **DFS**: 
  - Цей алгоритм слідує вздовж одного можливого шляху до максимальної глибини, перш ніж повернутися для перевірки інших шляхів.
  - У результаті DFS може повертати довші маршрути, оскільки глибина вибору може ігнорувати короткі шляхи.

- **BFS**:
  - BFS працює за принципом черги та перевіряє всі сусідні вершини на кожному рівні перед переходом до наступного.
  - Це гарантує, що знайдений шлях буде найкоротшим у термінах кількості ребер.

## Обґрунтування
1. **Чому DFS знаходить довший шлях?**
   DFS ігнорує кількість ребер і обирає глибокі переходи. Наприклад, у нашому випадку він переходить через сусідів `Eve`, `Frank`, і т.д., перш ніж знайти ціль.

2. **Чому BFS знаходить коротший шлях?**
   BFS систематично перевіряє всі вершини на поточному рівні, тому шлях завжди оптимальний за кількістю ребер.

## Висновки
- BFS краще підходить для пошуку найкоротшого шляху.
- DFS може бути корисним у ситуаціях, коли потрібно знайти **який-небудь** шлях, а не обов’язково найкоротший.